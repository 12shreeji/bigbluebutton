<?xml version="1.0" encoding="utf-8"?>
<bcast:MDIWindow xmlns:mx="http://www.adobe.com/2006/mxml" 
					  xmlns:bcast="flexlib.mdi.containers.*" 
					  implements="org.bigbluebutton.common.IBbbModuleWindow" preinitialize="onCreationComplete()"
					  xmlns:mate="http://mate.asfusion.com/" showCloseButton="false"
					  layout="absolute" backgroundColor="blue"
					  resize="onResize()" resizeEnd="onResize()"
					  >
	<mate:Listener type="{MadePresenterEvent.SWITCH_TO_PRESENTER_MODE}" method="becomePresenter" />
	<mate:Listener type="{MadePresenterEvent.SWITCH_TO_VIEWER_MODE}" method="becomeViewer" />
	
	<mx:Script>
		<![CDATA[
			import flexlib.mdi.events.MDIWindowEvent;
			
			import mx.core.UIComponent;
			import mx.events.ResizeEvent;
			
			import org.bigbluebutton.common.LogUtil;
			import org.bigbluebutton.main.events.MadePresenterEvent;
			import org.bigbluebutton.main.views.MainCanvas;
			import org.bigbluebutton.modules.broadcast.managers.BroadcastManager;
			import org.bigbluebutton.modules.broadcast.models.BroadcastOptions;
			import org.bigbluebutton.modules.broadcast.models.Stream;
			import org.bigbluebutton.modules.broadcast.models.Streams;
			
			public var broadcastManager:BroadcastManager;
			public var curStream:Stream;
			
			[Bindable]
			private var xPosition:int = 1;
			
			[Bindable]
			private var yPosition:int = 1;
			
			[Bindable]
			private var defHeight:int = 300;
			
			[Bindable]
			private var defWidth:int = 400;
			
			public var options:BroadcastOptions;
			
			[Bindable]
			public var streams:Streams;
			
			public var videoHolder2:UIComponent;
			
			private function onCreationComplete():void {
				xPosition = options.x;
				yPosition = options.y;
				defWidth = options.width;
				defHeight = options.height;
				this.x = options.x;
				this.y = options.y;
				this.width = options.width;
				this.height = options.height;
				onResize();
			}
			
			private function becomePresenter(e:MadePresenterEvent):void{
				videoStreamList.visible = true;
			}
			
			private function becomeViewer(e:MadePresenterEvent):void{
				videoStreamList.visible = false;
			}
			
			private function playStopVideo():void {
				if (playBtn.selected) {
					broadcastManager.playVideo(streamsComboBox.selectedIndex);	
					playBtn.label = "Stop";
				} else {
					playBtn.label = "Play";
					stopVideo();
				}
			}
			
			public function removeDisplay():void {
				videoHolder.removeChild(videoHolder2);			
			}
						
			private function stopVideo():void {
				broadcastManager.stopVideo();
			}
			
			public function getPrefferedPosition():String {	
				this.x = options.x;
				this.y = options.y;
				this.width = options.width;
				this.height = options.height;
				return options.position;
			}
			
			public function addDisplay():void {
				videoHolder2 = new UIComponent();
				videoHolder2.width = videoHolder.width;
				videoHolder2.height = videoHolder.height;
				videoHolder.addChild(videoHolder2);
			}
			
			public function onWindowResize():void {
				if (videoHolder2 != null && curStream != null) {	
//					curStream.resizeVideo(this.width, this.height);
					fitVideoToWindow();
					LogUtil.debug("vh=[" + this.width + "," + this.height + "," 
						+ videoHolder.width + "," + videoHolder.height + "," + videoHolder2.width + "," + videoHolder.height + "]");
					curStream.onResize();
				}
			}
			
			private function fitVideoToWindow():void {
				if (videoHolder2.width < videoHolder2.height) {
					fitToWidthAndAdjustHeightToMaintainAspectRatio();				
				} else {
					fitToHeightAndAdjustWidthToMaintainAspectRatio();
				}				
			}
			
			private function fitToWidthAndAdjustHeightToMaintainAspectRatio():void {						
				// Maintain aspect-ratio
				var aspectRatio:Number =  curStream.getAstpectRatio();
//				videoHolder2.width = videoHolder.width;	
//				videoHolder2.height = aspectRatio * videoHolder.height;
//				videoHolder2.width = this.width - 100;	
//				videoHolder2.height = this.height - 100;
				videoHolder2.width = videoHolder.width - 100;	
				videoHolder2.height = videoHolder.width * aspectRatio;
			}
			
			private function fitToHeightAndAdjustWidthToMaintainAspectRatio():void {			
				// Maintain aspect-ratio
				var aspectRatio:Number = curStream.getAstpectRatio();
//				videoHolder2.width = videoHolder.height * curStream.getAstpectRatio();		
//				videoHolder2.height = videoHolder.height;
//				videoHolder2.width = this.width - 100;	
//				videoHolder2.height = this.height - 100;
					
				videoHolder2.height = videoHolder.height - 100;
				videoHolder2.width = videoHolder.height / aspectRatio;
			}			
			
			static private var RESIZING_DIRECTION_UNKNOWN:int = 0; 
			static private var RESIZING_DIRECTION_VERTICAL:int = 1; 
			static private var RESIZING_DIRECTION_HORIZONTAL:int = 2; 
			static private var RESIZING_DIRECTION_BOTH:int = 3;
			private var resizeDirection:int = RESIZING_DIRECTION_BOTH;
			static public var PADDING_HORIZONTAL:Number = 6; // 10;
			static public var PADDING_VERTICAL:Number = 60; // 30;
			
			/**
			 * when the window is resized by the user, the application doesn't know
			 * about the resize direction
			 */
			public function onResizeStart(event:MDIWindowEvent = null):void {
				resizeDirection = RESIZING_DIRECTION_UNKNOWN;
			}
			
			/**
			 * after the resize ends, the direction is set to BOTH because of the
			 * non-user resize actions - like when the window is docked, and so on
			 */
			public function onResizeEnd(event:MDIWindowEvent = null):void {
				resizeDirection = RESIZING_DIRECTION_BOTH;
			}
			
			public function onResize():void {
				if (videoHolder2 == null || curStream == null) return;
				var aspectRatio:Number =  curStream.getAstpectRatio();
				
				// limits the window size to the parent size
//				this.width = (this.parent != null? Math.min(this.width, this.parent.width): this.width);
//				this.height = (this.parent != null? Math.min(this.height, this.parent.height): this.height); 
				
				var tmpWidth:Number = this.width - PADDING_HORIZONTAL;
				var tmpHeight:Number = this.height - PADDING_VERTICAL;
				
				// try to discover in which direction the user is resizing the window
				if (resizeDirection != RESIZING_DIRECTION_BOTH) {
					if (tmpWidth == videoHolder.width && tmpHeight != videoHolder.height)
						resizeDirection = (resizeDirection == RESIZING_DIRECTION_VERTICAL || resizeDirection == RESIZING_DIRECTION_UNKNOWN? RESIZING_DIRECTION_VERTICAL: RESIZING_DIRECTION_BOTH);
					else if (tmpWidth != videoHolder.width && tmpHeight == videoHolder.height)
						resizeDirection = (resizeDirection == RESIZING_DIRECTION_HORIZONTAL || resizeDirection == RESIZING_DIRECTION_UNKNOWN? RESIZING_DIRECTION_HORIZONTAL: RESIZING_DIRECTION_BOTH);
					else
						resizeDirection = RESIZING_DIRECTION_BOTH;
				}
				
				// depending on the direction, the tmp size is different
//				switch (resizeDirection) {
//					case RESIZING_DIRECTION_VERTICAL:
//						tmpWidth = Math.floor(tmpHeight * aspectRatio);
//						break;
//					case RESIZING_DIRECTION_HORIZONTAL:
//						tmpHeight = Math.floor(tmpWidth / aspectRatio);
//						break;
//					case RESIZING_DIRECTION_BOTH:
						// this direction is used also for non-user window resize actions
						tmpWidth = Math.min (tmpWidth, Math.floor(tmpHeight * aspectRatio));
						tmpHeight = Math.min (tmpHeight, Math.floor(tmpWidth / aspectRatio));
//						break;
//				}
				
				videoHolder2.width = videoHolder.width = tmpWidth;
				videoHolder2.height = videoHolder.height = tmpHeight;

				LogUtil.debug("vh=[" + this.width + "," + this.height + "," 
					+ videoHolder.width + "," + videoHolder.height + "," + videoHolder2.width + "," + videoHolder2.height + "]");
				curStream.onResize();
				
//				if (!keepAspect || this.maximized) {
					// center the video in the window
//					videoHolder.x = Math.floor ((this.width - PADDING_HORIZONTAL - tmpWidth) / 2);
//					videoHolder.y = Math.floor ((this.height - PADDING_VERTICAL - tmpHeight) / 2);
//				} else {
					// fit window dimensions on video
					videoHolder.x = 0;
					videoHolder.y = 0;
					this.width = tmpWidth + PADDING_HORIZONTAL;
					this.height = tmpHeight + PADDING_VERTICAL;
//				}
				
				// reposition the window to fit inside the parent window
/*				if (this.parent != null) {
					if (this.x + this.width > this.parent.width)
						this.x = this.parent.width - this.width;
					if (this.x < 0)
						this.x = 0;
					if (this.y + this.height > this.parent.height)
						this.y = this.parent.height - this.height;
					if (this.y < 0)
						this.y = 0;
				}
*/				

			}
			// horizontalAlign="center" verticalAlign="middle" 
		]]>
	</mx:Script>
		<mx:HBox id="videoHolder" width="100%" height="100%" backgroundColor="blue" horizontalAlign="center" verticalAlign="middle" 
				/>		
		<mx:ControlBar width="100%" height="30" paddingTop="0" borderStyle="outset" horizontalAlign="center">
			<mx:HBox x="1" y="1" id="videoStreamList" width="100%" height="30" horizontalAlign="center">
				<mx:ComboBox id="streamsComboBox" width="85%" dataProvider="{streams.streamNames}" />
				<mx:Button id="playBtn" label="Play" width="15% " click="playStopVideo()" toggle="true"/>				
			</mx:HBox>
		</mx:ControlBar>
</bcast:MDIWindow>
